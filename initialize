#!/usr/bin/env bash

# This is where all the magic happens! Just run this executable and follow
# the instructions.
#
# Exit codes:
#   1 - User chose to abort installation
#   2 - .dotfiles dir already exists

###########################################################################
##                                                                       ##
##                              Variables                                ##
##                                                                       ##
###########################################################################

export DOTFILES_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export COPY_DIR="$DOTFILES_HOME/copy"
export LINK_DIR="$DOTFILES_HOME/link"
export INIT_DIR="$DOTFILES_HOME/init"
export VENDORS="$DOTFILES_HOME/vendors"
SHELL_HOME=""

# Add bash binaries to PATH for use in the installation:
export PATH="$DOTFILES_HOME/bash/bin:$PATH"

###########################################################################
##                                                                       ##
##                         Supporting Functions                          ##
##                                                                       ##
###########################################################################

# Get permission from admin right at the beginning:
sudo -v

# Keep-alive: update existing `sudo` time stamp until the installer has finished:
while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

# Preps the user's environment for the installation:
function prep() {
    # Use custom color aliases:
    source "$DOTFILES_HOME/bash/source/colors.bash"

    # Ask user to overwrite existing install if applicable:
    if [[ -d ~/".dotfiles" ]]; then
        existing_install
    fi

    pull_submodules
}

# Prompt user whether or not to overwrite an existing install:
function existing_install() {
    local response=""
    while [[ ! $response =~ [Yy] && ! $response =~ [Nn] ]]; do
        echo "It appears that a .dotfiles directory already exists in your" 1>&2
        echo "user home. Do you want to overwrite it?" 1>&2
        read -sn 1 response
    done

    if [[ "$response" =~ [Yy] ]]; then
        rm -rf ~/".dotfiles"
    else
        echo "Aborting" 1>&2
        exit 2
    fi
}

function pull_submodules() {
    echo "Ensuring that submodules are cloned..." 1>&2
    pushd "$DOTFILES_HOME"
    git submodule update --init --recursive
    popd
}

# Ask user for shell type:
function determine_shell() {
    echo "Which installation would you like?" 1>&2
    local shell_type="$(clean-menu "bash" "zsh" "EXIT")"

    if [[ "$shell_type" == "EXIT" ]]; then
        echo "Aborting" 1>&2
        exit 1
    else
        SHELL_HOME="$DOTFILES_HOME/$shell_type"
    fi

    echo "Ok, you want a ${BLUE}$shell_type${NC} installation" 1>&2
    chsh -s "/bin/$shell_type"
}

# Returns the index of an array element
# Syntax: get_index_of array element
function get_index() {
    local arr=$1
    local element=$2

    for i in "${!arr[@]}"; do
         if [[ "${arr[$i]}" = "${element}" ]]; then
             echo "${i}";
         fi
    done
}

# Prompt user for larger applications to install:
function install_optional_brew_apps() {
    local cask_potential_apps=(dropbox macvim spotify sublime-text3 tower Done)
    local cask_apps_to_install=()

    echo "Select any additional apps to install from the menu. Select 'Done' when finished." 1>&2
    local response=""
    while [[ "$response" != "Done" ]]; do
        if [[ ${#cask_apps_to_install[@]} -gt 0 ]]; then
            echo "Apps Selected:" 1>&2
            echo "${cask_apps_to_install[@]}" 1>&2
        fi

        echo -e "\nSelect an App to Install:" 1>&2
        response="$(clean-menu ${cask_potential_apps[@]})"
        if [[ "$response" != "Done" ]]; then
            cask_apps_to_install+=("$response")
            local pos=$(get_index $cask_potential_apps $response)
            cask_potential_apps=(${cask_potential_apps[@]:0:$pos} ${cask_potential_apps[@]:$(($pos + 1))})
        fi
    done

    # Install the selected apps:
    for app in ${cask_apps_to_install[@]}; do
        brew cask install "$app"
    done
}

# Install depencies and prepare apps:
function init_step() {
    # Prep the locate database:
    "$INIT_DIR/init_locate"

    # Make sure that brew is installed and up-to-date:
    echo "Preparing Homebrew..." 1>&2
    "$INIT_DIR/init_homebrew"
    source "$INIT_DIR/brew_apps"

    # Prompt user to install larger apps:
    install_optional_brew_apps

    # Get powerline ready:
    local response=""
    while [[ ! $response =~ [Yy] && ! $response =~ [Nn] ]]; do
        echo "Would you like to install powerline and all dependencies?" 1>&2
        echo "If not, you can always install it later." 1>&2
        read -sn 1 response
        response=${response:-y}
    done
    if [[ "$response" =~ [Yy] ]]; then
        "$INIT_DIR/init_powerline"
    fi

    # Initialize Vim
    "$INIT_DIR/init_vim"
}

# Copy files:
function copy_step() {
    local copy_dir="$DOTFILES_HOME/copy"

    cp "$copy_dir/.vars" ~/.vars
    cp "$copy_dir/.dirs" ~/.dirs
    cp "$copy_dir/.path" ~/.path
    cp "$copy_dir/batcharge.py" ~/"bin/batcharge.py"
    cp "$copy_dir/online-check.sh" ~/"online-check.sh"

    if [[ -d "$DOTFILES_HOME/vendors/oh-my-zsh/themes" ]]; then
        cp "$copy_dir/tjtrabue.zsh-theme" "$DOTFILES_HOME/vendors/oh-my-zsh/themes/tjtrabue.zsh-theme"
    else
        echoe "It appears that the oh-my-zsh submodule hasn't been cloned."
        echo "Run 'git submodule update --init --recursive' from the .dotfiles" 1>&2
        echo "directory and copy tjtrabue.zsh-theme to oh-my-zsh/themes" 1>&2
    fi
}

# Link files:
function link_step() {
    local shell_link_dir="$SHELL_HOME/link"

    [[ ! -d ~/".config" ]] && mkdir ~/".config"

    ln -s "$LINK_DIR/powerline" "$HOME/.config/powerline"
    ln -s "$LINK_DIR/DotfileSnippets" \
        "$HOME/Library/Application Support/Sublime Text 3/Packages/User/DotfileSnippets"
    ln -s "$LINK_DIR/Preferences.sublime-settings" \
        "$HOME/Library/Application Support/Sublime Text 3/Packages/User/Prefences.sublime-settings"

    for f in "$shell_link_dir"/.[a-zA-Z]*; do
        ln -s "$f" "$HOME/$(basename $f)"
    done
}

# Prepare the last bits of the dev environment and reinvoke the login shell:
function finish() {
    unset COPY_DIR
    unset LINK_DIR
    unset INIT_DIR
    unset VENDORS

    exec $SHELL -i
}
trap finish EXIT # Make sure that finish() runs whenever the script exits

# Used for printing errors:
function echoe () { echo "${RED}ERROR${NC}: $@" 1>&2 ; }

# Used for printing warnings:
function echow () { echo "${YELLOW}WARNING${NC}: $@" 1>&2 ; }


###########################################################################
##                                                                       ##
##                             Main Program                              ##
##                                                                       ##
###########################################################################

# Get environment ready for the installation:
prep

# Get shell install type from the user:
determine_shell

# Init, copy, link files:
init_step
copy_step
link_step