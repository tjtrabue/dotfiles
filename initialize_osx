#!/usr/bin/env bash

# This is where all the magic happens! Just run this executable and follow
# the instructions.
#
# Exit codes:
#   1 - User chose to abort installation
#   2 - .dotfiles dir already exists

# Get permission from admin right at the beginning:
sudo -v

# Keep-alive: update existing `sudo` time stamp until the installer has finished:
while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &


################################################################################
##                                                                            ##
##                                  Variables                                 ##
##                                                                            ##
################################################################################

DOTFILES_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
COPY_DIR="$DOTFILES_HOME/copy"
LINK_DIR="$DOTFILES_HOME/link"
INIT_DIR="$DOTFILES_HOME/init"
VENDORS="$DOTFILES_HOME/vendors"

# Add bash binaries to PATH for use in the installation:
PATH="$DOTFILES_HOME/bash/bin:$PATH"

SHELL_HOME=""

export DOTFILES_HOME COPY_DIR LINK_DIR INIT_DIR VENDORS PATH

cask_apps=(
        alfred
        bartender
        coda
        dbvisualizer
        dropbox
        flux-beta
        gitkraken
        intellij-idea-ce
        iterm2-beta
        macpaw-gemini
        macvim
        moom
        spotify
        sublime-text3
        tower
        virtualbox-beta
)


################################################################################
##                                                                            ##
##                          Prep / Teardown Functions                         ##
##                                                                            ##
################################################################################

# Preps the user's environment for the installation:
function prep() {
    # Use custom color aliases:
    source "$DOTFILES_HOME/bash/source/colors.bash"

    pull_submodules
}

# Prepare the last bits of the dev environment and reinvoke the login shell:
function finish() {
    unset COPY_DIR
    unset LINK_DIR
    unset INIT_DIR
    unset VENDORS

    exec $SHELL -l
}
trap finish EXIT # Make sure that finish() runs whenever the script exits


################################################################################
##                                                                            ##
##                              Update Functions                              ##
##                                                                            ##
################################################################################

# Allow the user to choose from new casks
function install_new_casks {
    local installed_casks=( $(brew cask list) )
    local cask_apps_copy=("${cask_apps[@]}")

    for c in ${installed_casks[@]}; do
        local pos=$(get_index installed_casks $c)
        if [[ "$pos" -ge 0 ]]; then
            cask_apps_copy=(${cask_apps_copy[@]:0:$pos} ${cask_apps_copy[@]:$(($pos + 1))})
        fi
    done

    if [[ ${#cask_apps_copy[@]} -gt 0 ]]; then
        install_optional_brew_apps cask_apps_copy
    fi
}

# Prompt user whether or not to overwrite an existing install:
function existing_install() {
    brew cask update
    local response=""
    while [[ ! $response =~ [Yy] && ! $response =~ [Nn] ]]; do
        echow "It appears that a .dotfiles directory already exists in your"
        echo "user home. Do you want to overwrite it? [y/n]" 1>&2
        read -sn 1 response
    done

    if [[ "$response" =~ [Yy] ]]; then
        rm -rf ~/".dotfiles"
    else
        echo "Aborting" 1>&2
        exit 2
    fi
}


################################################################################
##                                                                            ##
##                          Initial Install Functions                         ##
##                                                                            ##
################################################################################

function pull_submodules() {
    echo "Ensuring that submodules are cloned..." 1>&2
    pushd "$DOTFILES_HOME"
        git submodule update --init --recursive
    popd
}

# Ask user for shell type:
function determine_shell() {
    echo "Which installation would you like?" 1>&2
    local shell_type="$(clean-menu "bash" "zsh" "EXIT")"

    if [[ "$shell_type" == "EXIT" ]]; then
        echo "Aborting" 1>&2
        exit 1
    else
        SHELL_HOME="$DOTFILES_HOME/$shell_type"
    fi

    echo "Ok, you want a ${BLUE}$shell_type${NC} installation" 1>&2
    chsh -s "/bin/$shell_type"
}

# Returns the index of an array element
# Syntax: get_index array_name (no $ in front of array name) $element
function get_index() {
    local array_name=$1[@]
    declare -a arr=("${!array_name}")
    local element=$2

    for i in "${!arr[@]}"; do
         if [[ "${arr[$i]}" == "${element}" ]]; then
             echo "${i}";
             exit 0
         fi
    done
    echo -1
}

# Prompt user for larger applications to install:
# Syntax:
#   install_optional_brew_apps array_name (no '$' in front of the array name)
function install_optional_brew_apps() {
    local arg_array=$1[@]
    declare -a arg_array_copy=("${!arg_array}")
    local cask_apps_to_install=()

    echo "Select any additional apps to install from the menu. Select 'DONE' when finished." 1>&2
    local response=""
    while [[ "$response" != "DONE" && ${#arg_array_copy[@]} -gt 1 ]]; do
        if [[ ${#cask_apps_to_install[@]} -gt 0 ]]; then
            echo "Apps Selected:" 1>&2
            local app
            for app in "${cask_apps_to_install[@]}"; do
                echo -e "${BLUE}$app${NC}" 1>&2
            done
        fi

        echo -e "\nSelect an App to Install:" 1>&2
        response="$(clean-menu ${arg_array_copy[@]} DONE)"
        if [[ "$response" != "DONE" ]]; then
            cask_apps_to_install+=("$response")
            local pos=$(get_index arg_array_copy $response)
            arg_array_copy=(${arg_array_copy[@]:0:$pos} ${arg_array_copy[@]:$(($pos + 1))})
            echo
        else
            echo
        fi
    done

    # Install the selected apps:
    for app in ${cask_apps_to_install[@]}; do
        brew cask install "$app"
    done
}

# Install depencies and prepare apps:
function init_step() {
    # Prep the locate database:
    echo "Initializing locate..." 1>&2
    "$INIT_DIR/init_locate"

    # Make sure that brew is installed and up-to-date:
    echo "Preparing Homebrew..." 1>&2
    "$INIT_DIR/init_homebrew"
    "$INIT_DIR/brew_apps"

    # Prompt user to install larger apps:
    install_optional_brew_apps cask_apps

    # Get powerline/fonts ready:
    local response=""
    while [[ ! $response =~ [Yy] && ! $response =~ [Nn] ]]; do
        echo -e "\nWould you like to install powerline and all dependencies?" 1>&2
        echo "If not, you can always install it later." 1>&2
        read -sn 1 response
        response=${response:-y}
    done
    if [[ "$response" =~ [Yy] ]]; then
        "$INIT_DIR/init_powerline"
        "$INIT_DIR/init_fonts"
    fi

    # Initialize Vim
    "$INIT_DIR/init_vim"
}

# Copy files:
function copy_step() {
    local copy_dir="$DOTFILES_HOME/copy"

    cp "$copy_dir/.vars" ~/.vars
    cp "$copy_dir/.dirs" ~/.dirs
    cp "$copy_dir/.path" ~/.path
    cp "$copy_dir/batcharge.py" ~/"bin/batcharge.py"
    cp "$copy_dir/online-check.sh" ~/"online-check.sh"

    if [[ -d "$DOTFILES_HOME/vendors/oh-my-zsh/themes" ]]; then
        cp "$copy_dir/tjtrabue.zsh-theme" "$DOTFILES_HOME/vendors/oh-my-zsh/themes/tjtrabue.zsh-theme"
    else
        echoe "It appears that the oh-my-zsh submodule hasn't been cloned."
        echo "Run 'git submodule update --init --recursive' from the .dotfiles" 1>&2
        echo "directory and copy tjtrabue.zsh-theme to oh-my-zsh/themes" 1>&2
    fi
}

# Link files:
function link_step() {
    local shell_link_dir="$SHELL_HOME/link"

    # Link the repo as a whole:
    ln -s "$DOTFILES_HOME" "$HOME/.dotfiles"

    [[ ! -d ~/".config" ]] && mkdir ~/".config"

    ln -s "$LINK_DIR/powerline" "$HOME/.config/powerline"
    ln -s "$LINK_DIR/DotfileSnippets" \
        "$HOME/Library/Application Support/Sublime Text 3/Packages/User/DotfileSnippets"
    ln -s "$LINK_DIR/Preferences.sublime-settings" \
        "$HOME/Library/Application Support/Sublime Text 3/Packages/User/Prefences.sublime-settings"

    for f in "$shell_link_dir"/.[a-zA-Z]*; do
        ln -s "$f" "$HOME/$(basename "$f")"
    done
}

# Used for printing errors:
function echoe () { echo "${RED}ERROR${NC}: $@" 1>&2 ; }

# Used for printing warnings:
function echow () { echo "${YELLOW}WARNING${NC}: $@" 1>&2 ; }


################################################################################
##                                                                            ##
##                                Main Program                                ##
##                                                                            ##
################################################################################

# Get environment ready for the installation:
prep

if [[ -f ~/".dotfiles/.dotfiles_installed" ]]; then
    existing_install
else
    # Get shell install type from the user:
    determine_shell

    # Init, copy, link files:
    init_step
    copy_step
    link_step

    touch ~/".dotfiles/.dotfiles_installed"
fi

# Take care of cleanup:
finish