#!/usr/bin/env bash

# This is where all the magic happens! Just run this executable and follow
# the instructions.
#
# Exit codes:
#   1 - User chose to abort installation
#   2 - .dotfiles dir already exists

# Get permission from admin right at the beginning:
sudo -v

# Keep-alive: update existing `sudo` time stamp until the installer has finished:
while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &


################################################################################
##                                                                            ##
##                                  Variables                                 ##
##                                                                            ##
################################################################################

DOTFILES_HOME="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
COPY_DIR="$DOTFILES_HOME/copy"
LINK_DIR="$DOTFILES_HOME/link"
INIT_DIR="$DOTFILES_HOME/init"
VENDORS="$DOTFILES_HOME/vendors"

# Add bash binaries to PATH for use in the installation:
PATH="$DOTFILES_HOME/bash/bin:$PATH"

SHELL_HOME=""

export DOTFILES_HOME COPY_DIR LINK_DIR INIT_DIR VENDORS PATH

# The list of all my favorite developer tools to install via Homebrew Cask:
cask_apps=(
        adobe-reader
        alfred
        bartender
        coda
        dbvisualizer
        dropbox
        flux-beta
        gitkraken
        intellij-idea
        iterm2-beta
        macpaw-gemini
        macvim
        moom
        spotify
        sublime-text3
        tower
        virtualbox-beta
        webstorm
)


################################################################################
##                                                                            ##
##                          Prep / Teardown Functions                         ##
##                                                                            ##
################################################################################

# Preps the user's environment for the installation:
function prep() {
    # Use custom color aliases:
    source "$DOTFILES_HOME/bash/source/colors.bash"

    pull_submodules
}

# Prepare the last bits of the dev environment and reinvoke the login shell:
function finish() {
    unset COPY_DIR
    unset LINK_DIR
    unset INIT_DIR
    unset VENDORS

    exec $SHELL -l
}
trap finish EXIT # Make sure that finish() runs whenever the script exits


################################################################################
##                                                                            ##
##                              Update Functions                              ##
##                                                                            ##
################################################################################

# Prompt the user to install new Homebrew Casks:
function install_new_casks() {
    echo "Looking for new Homebrew apps..." 1>&2
    local installed_casks=( $(dir -1 /opt/homebrew-cask/Caskroom) )
    local cask_apps_copy=("${cask_apps[@]}")

    for c in ${installed_casks[@]}; do
        remove_element cask_apps_copy "$c"
    done

    if [[ ${#cask_apps_copy[@]} -gt 0 ]]; then
        install_optional_brew_apps cask_apps_copy
    fi
}

# Prompt user whether or not to overwrite an existing install:
function existing_install() {
    git pull origin master
    brew cask update
    install_new_casks
}


################################################################################
##                                                                            ##
##                          Initial Install Functions                         ##
##                                                                            ##
################################################################################

function pull_submodules() {
    echo "Ensuring that submodules are cloned..." 1>&2
    pushd "$DOTFILES_HOME"
        git submodule update --init --recursive
    popd
}

# Ask user for shell type:
function determine_shell() {
    echo "Which installation would you like?" 1>&2
    local shell_type="$(menu "bash" "zsh" "EXIT")"

    if [[ "$shell_type" == "EXIT" ]]; then
        echo "Aborting" 1>&2
        exit 1
    else
        SHELL_HOME="$DOTFILES_HOME/$shell_type"
    fi

    echo -e "Ok, you want a ${BLUE}$shell_type${NC} installation" 1>&2
    chsh -s "/bin/$shell_type"
}

# Returns the index of an array element
# Syntax:
#   get_index array_name (no $ in front of array_name) $element
function get_index() {
    local array_name=$1[@]
    declare -a arr=("${!array_name}")
    local element=$2

    for i in "${!arr[@]}"; do
         if [[ "${arr[$i]}" == "${element}" ]]; then
             echo "${i}";
             exit 0
         fi
    done
    echo -1
}

# Removes a specified element from an array. If more than one of the same
# element exist in the array, it removes the first occurance.
#
# Syntax:
#   remove_element array_name (no $ in front of array_name) $element
function remove_element() {
    if [[ "$#" -ne 2 ]]; then
        echoe "remove_element - incorrect number of parameters supplied"
        return 1
    fi
    local array_name=$1[@]
    declare -a arr=("${!array_name}")
    local element=$2
    local pos=$(get_index arr $element)
    if [[ "$pos" -ge 0 ]]; then
        arr=(${arr[@]:0:$pos} ${arr[@]:$(($pos + 1))})
    fi
}

# Prompt user for larger applications to install:
# Syntax:
#   install_optional_brew_apps array_name (no '$' in front of the array name)
function install_optional_brew_apps() {
    local function_loop_control=false
    while ! $function_loop_control; do
        local arg_array=$1[@]
        declare -a arg_array_copy=("${!arg_array}")
        local cask_apps_to_install=()

        echo "Select any additional apps to install from the menu. Select 'DONE' when finished." 1>&2
        local response=""
        while [[ "$response" != "DONE" && ${#arg_array_copy[@]} -gt 1 ]]; do
            if [[ ${#cask_apps_to_install[@]} -gt 0 ]]; then
                echo "Apps Selected:" 1>&2
                local app
                for app in "${cask_apps_to_install[@]}"; do
                    echo -e "${BLUE}$app${NC}" 1>&2
                done
            fi

            echo -e "\nSelect an App to Install:" 1>&2
            response="$(menu ${arg_array_copy[@]} DONE)"
            if [[ "$response" != "DONE" ]]; then
                cask_apps_to_install+=("$response")
                remove_element arg_array_copy "$response"
                echo
            else
                echo
            fi
        done

        response=""
        while [[ ! $response =~ [Yy] && ! $response =~ [Nn] ]]; do
            echo "These are the apps you've selected to install:" 1>&2
            for app in "${cask_apps_to_install[@]}"; do
                echo -e "${BLUE}$app${NC}" 1>&2
            done
            echo "Is this correct? [y/n]" 1>&2
            read -sn 1 response
        done
        if [[ "$response" =~ [Yy] ]]; then
            # Install the selected apps:
            for app in ${cask_apps_to_install[@]}; do
                brew cask install "$app"
            done
            function_loop_control=true
        fi
    done
}

# Install depencies and prepare apps:
function init_step() {
    # Prep the locate database:
    echo "Initializing locate..." 1>&2
    "$INIT_DIR/init_locate"

    # Make sure that brew is installed and up-to-date:
    echo "Preparing Homebrew..." 1>&2
    "$INIT_DIR/init_homebrew"
    "$INIT_DIR/brew_apps"

    # Prompt user to install larger apps:
    install_optional_brew_apps cask_apps

    # Get powerline/fonts ready:
    local response=""
    while [[ ! $response =~ [Yy] && ! $response =~ [Nn] ]]; do
        echo -e "\nWould you like to install powerline and all dependencies?" 1>&2
        echo "If not, you can always install it later." 1>&2
        read -sn 1 response
        response=${response:-y}
    done
    if [[ "$response" =~ [Yy] ]]; then
        "$INIT_DIR/init_powerline"
        "$INIT_DIR/init_fonts"
    fi

    # Initialize Vim
    "$INIT_DIR/init_vim"

    # Initialize Git
    "$INIT_DIR/init_git"
}

# Copy files:
function copy_step() {
    local copy_dir="$DOTFILES_HOME/copy"

    cp "$copy_dir/.vars" ~/.vars
    cp "$copy_dir/.dirs" ~/.dirs
    cp "$copy_dir/.path" ~/.path
    cp "$copy_dir/batcharge.py" ~/"bin/batcharge.py"
    cp "$copy_dir/online-check.sh" ~/"online-check.sh"

    if [[ -d "$DOTFILES_HOME/vendors/oh-my-zsh/themes" ]]; then
        cp "$copy_dir/tjtrabue.zsh-theme" "$DOTFILES_HOME/vendors/oh-my-zsh/themes/tjtrabue.zsh-theme"
    else
        echoe "It appears that the oh-my-zsh submodule hasn't been cloned."
        echo "Run 'git submodule update --init --recursive' from the .dotfiles" 1>&2
        echo "directory and copy tjtrabue.zsh-theme to oh-my-zsh/themes" 1>&2
    fi
}

# Link files:
function link_step() {
    local shell_link_dir="$SHELL_HOME/link"

    # Link the repo as a whole:
    ln -s "$DOTFILES_HOME" "$HOME/.dotfiles"

    [[ ! -d ~/".config" ]] && mkdir ~/".config"

    ln -s "$LINK_DIR/powerline" "$HOME/.config/powerline"
    ln -s "$LINK_DIR/DotfileSnippets" \
        "$HOME/Library/Application Support/Sublime Text 3/Packages/User/DotfileSnippets"
    ln -s "$LINK_DIR/Preferences.sublime-settings" \
        "$HOME/Library/Application Support/Sublime Text 3/Packages/User/Prefences.sublime-settings"

    # Link shell-specific files:
    for f in "$shell_link_dir"/.[a-zA-Z]*; do
        ln -s "$f" "$HOME/$(basename "$f")"
    done

    # Link git configuration files:
    for gf in "$DOTFILES_HOME/git/link"/*; do
        ln -s "$gf" "$HOME/$(basename "$gf")"
    done
}

# Used for printing errors:
function echoe () { echo -e "${RED}ERROR${NC}: $@" 1>&2 ; }

# Used for printing warnings:
function echow () { echo -e "${BROWN_ORANGE}WARNING${NC}: $@" 1>&2 ; }


################################################################################
##                                                                            ##
##                                Main Program                                ##
##                                                                            ##
################################################################################

# Get environment ready for the installation:
prep

if [[ -f ~/".dotfiles/.dotfiles_installed" ]]; then
    existing_install
else
    # Get shell install type from the user:
    determine_shell

    # Init, copy, link files:
    init_step
    copy_step
    link_step

    touch ~/".dotfiles/.dotfiles_installed"
fi

# Take care of cleanup:
finish