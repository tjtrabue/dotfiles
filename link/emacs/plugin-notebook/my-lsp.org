#+title:  LanguageServerProtocol Client
#+author: Tom Trabue
#+email:  tom.trabue@gmail.com
#+date:   2020:05:25

Language Server Protocol client (=lsp-mode=) configuration.  It is highly advised
that you run Emacs version 27+ in order to get the best performance out of LSP
mode due to Emacs 27's native JSON parsing capability.

If you run =lsp= and get a message like '<filename> not in project or was
blacklisted' you can fix the problem with: =M-x lsp-workpace-blacklist-remove=

* Notes about specific LSP servers
  - *CCLS*: Available as an AUR packge on Arch Linux. This LSP server requires the
    =ccls= Emacs package from MELPA, as well.
  - *EmmyLua LanguageServer*: Available as an AUR packge on Arch Linux.
    Make sure to rename EmmyLua's =.jar= file to =EmmyLua-LS-all.jar= and put it
    in the =~/.emacs.d/= directory.
  - *haskell-ide-engine*: Available as an AUR packge on Arch Linux.

* Variables
  Define special =lsp-mode= variables here.

#+begin_src emacs-lisp :tangle yes
  (defvar my/lsp-format-major-mode-blacklist '(
      lua-mode
      python-mode
      sh-mode
    )
    "List of major modes to ignore when activating lsp-format hooks, usually
because the LSP server for these major modes does not yet support document
formatting, or because their formatters are lacking in features. Thankfully
the reformatter package provides a generic interface for creating formatters
for any programming language that supports a formatting tool.")

  (defvar my/lsp-enabled-modes '(
      c-mode
      c++-mode
      clojure-mode
      cmake-mode
      css-mode
      elixir-mode
      go-mode
      haskell-mode
      html-mode
      java-mode
      javascript-mode
      js-mode
      json-mode
      LaTeX-mode
      less-css-mode
      lua-mode
      objc-mode
      perl-mode
      php-mode
      python-mode
      ruby-mode
      scss-mode
      sh-mode
      tex-mode
      xml-mode
      yaml-mode)
    "List of all major modes allowing `lsp-mode' to run as a minor mode.")
#+end_src

* Functions
  Extra helper functions for defining major mode hooks for =lsp-mode= and such.

#+begin_src emacs-lisp :tangle yes
    (defun my/lsp-add-format-on-save-hook (mode)
      "This function adds a buffer local hook for the major mode represented by
  MODE that runs `lsp-format-buffer' before saving the buffer's file."
      ;; Ignore major-modes listed in the blacklist variable.
      (unless (member mode my/lsp-format-major-mode-blacklist)
        ;; Make sure to take out the format-all hook so that we don't use
        ;; two different formatting systems for the same buffer.
        (remove-hook 'before-save-hook #'format-all-buffer--from-hook 'local)
        (add-hook 'before-save-hook #'lsp-format-buffer 0 'local)))

    (defun my/add-lsp-mode-hooks ()
      "Add hooks to the major modes specified in `my/lsp-enabled-modes' to
  automatically start lsp-mode when editing files associated with those major
  modes, as well as format buffers on save."
      (mapc #'(lambda (mode)
                ;; This is necessary for providing closure-like behavior
                (lexical-let ((mode mode)
                              (hook-name (concat (symbol-name mode) "-hook")))
                   (add-hook (intern hook-name) #'(lambda ()
                    ;; Automatically start lsp when you visit a relevant file
                    (lsp-deferred)
                    ;; Format lsp-mode buffers on save.
                    (my/lsp-add-format-on-save-hook mode)))))
          my/lsp-enabled-modes))

    (defun my/check-lsp-enabled-for-mode-p (mode &optional all &rest modes)
      "Return non-nil if a specific MODE is enabled for `lsp-mode' based on the
  value of `my/lsp-enabled-modes'.

  MODES are optional additional major modes to check for in
  `my/enabled-mode-for-lsp'. The behavior of the check depends on the value of
  ALL.

  The optional ALL argument is a truthy value determining whether or not all
  specified major modes appear in `my/enabled-mode-for-lsp'. If ALL is non-nil,
  then the final result of this function will only be non-nil if all supplied
  modes are present in `my/enabled-mode-for-lsp'. If ALL is nil, then the result
  of this function will be non-nil if any of the supplied major modes are in the
  list."
      (require 'cl-lib)
      (if modes
          (let ((full-modes (cons mode modes)))
            (if all
                (not (cl-set-difference full-modes my/lsp-enabled-modes))
              (cl-intersection full-modes my/lsp-enabled-modes)))
        (member mode my/lsp-enabled-modes)))
#+end_src

* lsp-mode
  =lsp-mode= is the actual LanguageServerProtocol client for Emacs. It does the
  heavy lifting of starting up Language Servers and managing connections to
  them, not to mention all the fancy UI stuff regarding completions,
  documentation on hover, syntax linting and error checking, etc.

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-mode
    :after (format-all)
    :bind-keymap
    ;; Redefine lsp command prefix (default is "s-l" which messes with
    ;; most window managers).
    ("C-c l" . lsp-command-map)
    :bind
    (:map lsp-command-map
      ;; Need to bind lsp-treemacs commands here instead of in its own
      ;; use-package specification because these keybindings do not take
      ;; if we do that.
      ("t c" . lsp-treemacs-call-hierarchy)
      ("t e" . lsp-treemacs-errors-list)
      ("t i" . lsp-treemacs-implementations)
      ("t r" . lsp-treemacs-references)
      ("t s" . lsp-treemacs-symbols)
      ("t t" . lsp-treemacs-type-hierarchy))
    :hook
    ;; NOTE: Language mode hooks are set in the Functions section of this
    ;;       file.
    ;; Enable which-key integration for lsp-mode
    (lsp-mode . lsp-enable-which-key-integration)
    :commands (lsp lsp-deferred)
    :init
    (my/add-lsp-mode-hooks)
    (setq lsp-keymap-prefix "C-c l"
          lsp-enable-snippet t
          lsp-log-io t ;; Use this to enable debugging output
          lsp-enable-semantic-highlighting t
          lsp-bash-highlight-parsing-errors t
          ;; Increase the number of simultaneously watchable files
          ;; (the default number is 1000).
          ;; If nil, then no warning is printed for any number of files.
          lsp-file-watch-threshold 100000
          ;; Make sure we are using completion at point.
          lsp-completion-provider :capf
          ;; The length that lsp-mode waits to begin completion
          lsp-idle-delay 0.000))
#+end_src

* Plugins
** lsp-ui

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-ui
    :after (lsp-mode)
    :commands lsp-ui-mode
    :hook (lsp . lsp-ui)
    :bind
    (:map lsp-ui-mode-map
     ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
     ([remap xref-find-references] . lsp-ui-peek-find-references))
    :init
    (setq lsp-ui-sideline-ignore-duplicate t
          ;; How long to wait before showing documentation in a floating window
          lsp-ui-doc-delay 0.2
          lsp-ui-peek-enable t
          ;; Show directories of files
          lsp-ui-peek-show-directory t
          lsp-ui-doc-enable t))
#+end_src

** lsp-haskell

#+begin_src emacs-lisp :tangle yes
  ;; NOTE: This plugin requires that the haskell-ide-engine package be
  ;;       installed on your system.
  (use-package lsp-haskell
    :after (lsp-mode)
    :hook
    ((haskell-mode literate-haskell-mode) . (lambda ()
          (haskell-indentation-mode)
          ;; Autoeomplete snippets
          (lsp-haskell-set-completion-snippets-on))))
#+end_src

** lsp-java

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-java
    :after (lsp-mode))
#+end_src

** lsp-treemacs

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-treemacs
    :after (lsp-mode treemacs)
    :commands (lsp-treemacs-errors-list)
    :hook
    ((lsp-mode . (lambda ()
                    ;; Enable bidirectional sync of lsp workspace folders
                    ;; and treemacs projects.
                    (lsp-treemacs-sync-mode 1)))
     (java-mode . (lambda ()
                     (define-key lsp-command-map (kbd "t d")
                       'lsp-treemacs-java-deps-list)))))
#+end_src

** ccls
   =ccls= is a great language server for C/C++. It started as a fork of the
   =cquery= language server, but has since improved upon =cquery='s shortcomings
   immensely. For instance, =cquery= imposed a massive memory footprint on even
   medium sized projects, whereas =ccls= is far more memory efficient. At the
   same time there are benefits to being a fork of such a complete language
   server. =cquery= is a nearly complete language server, implementing just
   about the entire LSP specification, so =ccls= inherits that completeness, and
   as such can provide all of the tooling promised by the ambitious LSP spec.

   Another fantastic =ccls= feature is its interoperability with numerous build
   systems, including Make, Ninja, CMake, and many more. Thus, if you use CMake
   for your project's build tool chain, and you have a =project_config.h.in=
   configuration file commonly used in CMake projects, then =ccls= will pick up
   on the fact that CMake generates a =project_config.h= file from your
   configuration template file, and will act as if the =project_config.h= file
   is already present and ready to use. Many other LSP systems would complain if
   your source code references a =.h= file that is not yet physically present on
   your file system.

*** variables
#+begin_src emacs-lisp :tangle yes
  (defvar my/ccls-compile-commands-map (make-hash-table :test 'equal)
    "Hash table associating build tool names to their associated internal
data structure used to generate the debug cache for CCLS.")
#+end_src

*** structures
#+begin_src emacs-lisp :tangle yes
  (cl-defstruct my/ccls-gen-compile-commands
    "Structure defining a generic CCLS command and arguments for generating the
compile_commands.json file and other debugging information that CCLS makes use
of."
    command args)
#+end_src

*** helper functions
#+begin_src emacs-lisp :tangle yes
  (defun my/insert-semicolon-eol ()
    "Insert ';' at the end of the current line and moves point to EOL."
    (interactive)
    (move-end-of-line nil)
    (insert ";"))

  (defun my/ccls--create-compile-commands-structs ()
    "Create a number of different structs corresponding to different build tools
 used to create CCLS's debug cache."
    (let ((ccstruct-list `(,(make-my/ccls-gen-compile-commands
                              :command "cmake" :args '("-H." "-BDebug"
                                      "-DCMAKE_BUILD_TYPE=Debug"
                                      "-DCMAKE_EXPORT_COMPILE_COMMANDS=YES")))))
      (cl-loop for struct in ccstruct-list do
             (puthash (my/ccls-gen-compile-commands-command struct)
                      struct my/ccls-compile-commands-map))))

  (defun my/ccls-gen-compile-commands-json ()
    "Generate the compile_commands.json file for a CCLS project."
    (interactive)
    (when (= 0 (hash-table-count my/ccls-compile-commands-map))
      ;; Create the command-struct hash map if it has not yet been initialized.
      (my/ccls--create-compile-commands-structs))
    (let* ((output-buffer-name "*ccls-compile-commands*")
           (default-directory (if (fboundp 'projectile-project-root)
                                    (projectile-project-root)))
           (output-buffer (get-buffer-create output-buffer-name))
           (compile-commands-file "compile_commands.json")
           (user-window (selected-window))
           (selected-command-struct
             (gethash "cmake" my/ccls-compile-commands-map))
           ;; The generator function to apply to arguments later on
           (gen-compile-commands (apply-partially 'call-process
             (my/ccls-gen-compile-commands-command selected-command-struct)
               nil output-buffer 'redisplay-buffer)))
      (unless (file-exists-p (expand-file-name ".ccls"))
          (error "ERROR: No .ccls file found in project root."))
      (if default-directory
          (with-current-buffer output-buffer
              (erase-buffer)
              (switch-to-buffer-other-window output-buffer t)
              (apply gen-compile-commands (my/ccls-gen-compile-commands-args
                  selected-command-struct))
              (call-process "ln" nil nil nil "-s"
                          (concat "Debug/" compile-commands-file)
                          ".")
              (select-window user-window))
         (error "ERROR: Not in a projectile project."))))
#+end_src

*** use-package specification
#+begin_src emacs-lisp :tangle yes
  ;; LSP language clients
  ;; CCLS - For use with C, C++, and Objective C
  ;;
  ;; NOTE: If a C/C++ file is opened in Emacs and CCLS fails to
  ;;       provide its services automatically then most likely CCLS
  ;;       cannot find the project's root directory (or has been confused
  ;;       by projectile). Put a ".ccls-root" file in the project root
  ;;       directory to fix this problem.
  (use-package ccls
    :bind
    (:map evil-insert-state-map
    ("<C-return>" . my/insert-semicolon-eol))
    :init
    (setq ccls-executable (executable-find "ccls"))
    ;; Always use flycheck, not flymake.
    (setq lsp-diagnostic-package :auto)
    ;; Turn off other syntax checkers
    (setq-default flycheck-disabled-checkers
                  '(c/c++-clang c/c++-cppcheck c/c++-gcc))
    :hook
    ;; NOTE: CMake now has its own language server: cmake-language-server
    ;;       which is a Python package.
    ((c-mode c++-mode objc-mode makefile-mode) . (lambda ()
        (require 'ccls))))
#+end_src

** lsp-elixir

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-elixir
    :after (lsp-mode)
    :hook elixir-mode)
#+end_src

** lsp-intellij

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-intellij
    :after (lsp-mode)
    :hook java-mode)
#+end_src

** lsp-origami

#+begin_src emacs-lisp :tangle yes
  (use-package lsp-origami
    :after (lsp-mode))
#+end_src
