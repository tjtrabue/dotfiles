#+title:  evil-mode Configuration
#+author: Tom Trabue
#+email:  tom.trabue@gmail.com
#+date:   2020:05:25
#+STARTUP: fold

The Extensible VI Layer (AKA evil.  AKA the only way to use Emacs).
=evil-mode= is a fully featured VI emulator for Emacs, even improving upon the
features of Vim at times.

*If Evil Mode treats 'd' like 'dd', 'c' like 'cc', etc*: You need delete the
\*Backtrace\* buffer!!! This problem has been plaguing me since day 1 of using
Evil, and I hate it! If deleting \*Backtrace\* doesn't work, there's probably
some other buffer you need to delete to get Evil working again. Remember, you
can turn off automatic error debugging by changing the =debug-on-error= variable
to =nil=, so this may help you.

* Define custom evil operators
  An =evil-operator= is a function that acts on text objects (characters, words,
  lines, etc.). They are designed to mimic Vim's operators.

  #+begin_src emacs-lisp
    (eval-when-compile
      (unless (fboundp 'my/define-custom-evil-operators)
        (defun my/define-custom-evil-operators ()
          "Define extra operators for use in `evil-mode'."

          ;; FIXME
          ;; when done on line:
          ;;     (insert "\n#endif  // " ident)))))
          ;; it modifies the string and becomes:
          ;;     (insert "\n#endif // " ident)))))
          ;;
          ;; if joined lines are comments, remove delimiters
          (evil-define-operator my-evil-join (beg end)
            "Join the selected lines. Based on blaenk/dots on GitHub.

    This custom version of `evil-join' handles joining commented
    lines more handily than evil's default J operator, removing
    leading comment designators. In that sense, it behaves far more
    like Vim."
            :motion evil-line
            (let* ((count (count-lines beg end))
                   ;; we join pairs at a time
                   (count (if (> count 1) (1- count) count))
                   ;; the mark at the middle of the joined pair of lines
                   (fixup-mark (make-marker)))
              (dotimes (var count)
                (if (and (bolp) (eolp))
                    (join-line 1)
                  (let* ((end (line-beginning-position 3))
                         (fill-column (1+ (- end beg))))
                    ;; save the mark at the middle of the pair
                    (set-marker fixup-mark (line-end-position))
                    ;; join it via fill
                    (fill-region-as-paragraph beg end)
                    ;; jump back to the middle
                    (goto-char fixup-mark)
                    ;; context-dependent whitespace fixup
                    (fixup-whitespace))))
              ;; remove the mark
              (set-marker fixup-mark nil))))))
  #+end_src

* Custom advice functions
  Evil mode functions will call these advice functions back automatically based
  on their parameters.

** Define advice functions
   #+begin_src emacs-lisp
     (eval-when-compile
       (defun my/highlight-evil-region-advice (orig-fn beg end &rest args)
         "Pulse a selected buffer region with a highlight for a moment."
         (pulse-momentary-highlight-region beg end 'highlight)
         (apply orig-fn beg end args)))
   #+end_src

** Add advice to evil functions
   #+begin_src emacs-lisp
     (defun my/add-evil-advice ()
       "Add advice to various `evil-mode' functions."
       (advice-add 'evil-yank :around 'my/highlight-evil-region-advice))
   #+end_src

* use-package specification
  The Evil mode plugin itself.

  *NOTE*: If you want to use =evil-leader=, you need to load =evil-leader=
  /before/ loading =evil=.

  #+begin_src emacs-lisp
    (use-package evil
      :after (evil-leader key-chord)
      :demand t
      :bind
      (:map evil-normal-state-map
            ("H" . evil-window-top)
            ("L" . evil-window-bottom)
            ;; Only scroll half a page up/down with C-b and C-f instead of a
            ;; full page.
            ([remap evil-scroll-page-up] . evil-scroll-up)
            ([remap evil-scroll-page-down] . evil-scroll-down)
            ("C-e" . switch-to-buffer)
            :map evil-insert-state-map
            ;; TAB key should insert spaces to next tab stop, like in Vim.
            ("<tab>" . tab-to-tab-stop)
            ;; Get rid of annoying evil-paste-from-register binding.
            ("C-r" . nil))
      :custom
      ;; NOTE: We must set variables for evil-mode's initialization in evil-leader's
      ;;       use-package directive because it loads first, and it in turn loads
      ;;       evil mode.
      ;; Which search library to use for '/' and '?'.
      ;; Defaults to 'isearch, but 'evil-search is a bit better.
      (evil-search-module 'evil-search)
      :config
      ;; Enable evil-mode globally
      (evil-mode 1)
      ;; Revert back to normal mode with 'jk'
      ;; Have to use key-chord.el because define-key will keep us from
      ;; ever typing 'j' as text since j will thitherto be a leader key in
      ;; evil-insert-state-mode.
      (let ((revert-to-normal "jk"))
        (key-chord-define evil-insert-state-map revert-to-normal
                          'evil-normal-state)
        (key-chord-define evil-replace-state-map revert-to-normal
                          'evil-normal-state))
      (my/define-custom-evil-operators)
      (my/add-evil-advice)
      ;; Use custom "J" command that removes leading comment designators.
      (define-key evil-normal-state-map [remap evil-join] 'my-evil-join))
  #+end_src

* Plugins
** evil-leader
   =evil-leader= is an emulator for Vim's mapleader feature allowing users to
   define key bindings based on pressing a leader key (usually comma) followed
   by an arbitrary succession of additional key strokes to call a predefined
   function. It's similar in nature to Emacs' =key-chord= plugin.

   #+begin_src emacs-lisp
     (use-package evil-leader
       :demand t
       :hook
       (after-init . global-evil-leader-mode)
       :init
       ;; Set evil-mode variables here.
       ;; These values must be set here because evil-leader loads before evil
       ;; itself. Thus, these variables will have already been set by the time
       ;; Evil's use-package specification loads, making any variable definitions
       ;; set there useless.
       ;;
       ;; Tell Evil that 'Y' in normal state yanks from point to the end of line
       ;; as opposed to the entire line like 'yy'.
       (setq evil-want-Y-yank-to-eol t
             ;; Need this for evil-collection; loads evil-integration.el
             evil-want-integration t
             ;; Do not use any default keybinding since evil-collection
             ;; takes care of that part.
             evil-want-keybinding nil)
       ;; Make '>>' and '<<' commands indent according to Emacs' tab width.
       (setq-default evil-shift-width tab-width
                     ;; '>>' and '<<' should round indent to the next nearest tab stop.
                     evil-shift-round t)
       :custom
       (evil-leader/leader ",")
       :config
       (evil-leader/set-key
         "m" 'evil-first-non-blank
         "." 'evil-end-of-line
         ;; Buffer
         "bb" 'switch-to-buffer
         "bk" 'kill-this-buffer
         ;; Dired
         "dd" 'dired
         ;; eshell
         "es" 'eshell-below
         ;; Git/Magit
         "gg" 'magit-status
         "gd" 'magit-dispatch
         "gtt" 'git-timemachine-toggle
         ;; ace-window
         "jk" 'ace-window
         ;; Killing buffers
         "kk" 'kill-buffer
         ;; File
         "lf" 'load-file
         "of" 'org-babel-load-file
         ;; Flycheck
         "fn" 'flycheck-next-error
         "fp" 'flycheck-previous-error
         ;; File searching
         "rg" 'deadgrep
         ;; undo-tree
         "ut" 'undo-tree-visualize)
       ;; Leader shortcuts for dired-mode.
       (evil-leader/set-key-for-mode 'dired-mode
         "dC" 'dired-do-copy-regexp
         "dG" 'dired-mark-files-containing-regexp
         "dM" 'dired-mark-files-regexp
         "dR" 'dired-do-rename-regexp
         "dS" 'dired-do-symlink-regexp
         "dY" 'dired-do-relsymlink-regexp))
   #+end_src

** evil-collection
   Used to provide default Vim keybindings for all standard Emacs modes.
   #+begin_src emacs-lisp
     (use-package evil-collection
       :after evil
       :demand t
       :bind
       (:map evil-normal-state-map
             ;; Unbind some unused mappings
             ("M-." . nil))
       :custom
       ;; Whether or not to use Vim keys in the minibuffer.
       (evil-collection-setup-minibuffer t)
       :config
       (evil-collection-init)
       ;; Get rid of troublesome keybindings (must come here in the :config block):
       ;; We do not need to kill a line with C-k anymore since we're using
       ;; Vim keys.
       (global-unset-key (kbd "C-k"))
       ;; We never need to insert digraphs!
       (define-key evil-insert-state-map (kbd "C-k") nil))
   #+end_src

** evil-surround
   #+begin_src emacs-lisp
     (use-package evil-surround
       :after evil-collection
       :hook
       (after-init . global-evil-surround-mode))
   #+end_src

** evil-numbers
   #+begin_src emacs-lisp
     (use-package evil-numbers
       :demand t
       :config
       (define-key evil-normal-state-map (kbd "C-c +") 'evil-numbers/inc-at-pt)
       (define-key evil-normal-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt))
   #+end_src

** evil-commentary
   Code commenting plugin based on =vim-commentary= for Vim.

   #+begin_src emacs-lisp
     (use-package evil-commentary
       ;; Disabled in favor of evil-nerd-commenter
       :disabled
       :after evil-collection
       :hook
       (after-init . evil-commentary-mode))
   #+end_src

** evil-nerd-commenter
   A powerful and configurable code commenting plugin based on =NerdCommenter=
   for Vim. Unlike =evil-commentary=, this plugin does not come with any default
   keybindings. You must assign them as you see fit, and I just so happen to
   have my keybindings set up to mirror =evil-commentary='s default
   configuration.

   #+begin_src emacs-lisp
     (use-package evil-nerd-commenter
       :after evil-collection
       :bind*
       (:map evil-normal-state-map
             ("g c c" . evilnc-comment-or-uncomment-lines)
             ("g c l" . evilnc-quick-comment-or-uncomment-to-the-line)
             ("g c p" . evilnc-comment-or-uncomment-paragraphs)
             ("g c r" . comment-or-uncomment-region)
             :map evil-visual-state-map
             ("g c" . evilnc-comment-or-uncomment-lines)
             ("g C" . comment-or-uncomment-region)))
   #+end_src

** evil-mark-replace
   Replace symbol at point in marked area. This plugin is not terribly useful,
   given the advent of powerful IDE plugins such as =lsp-mode=, but it still may
   be marginally useful at times.

   #+begin_src emacs-lisp
     (use-package evil-mark-replace
       :disabled
       :after evil-collection
       :demand t)
   #+end_src

** evil-matchit
   #+begin_src emacs-lisp
     (use-package evil-matchit
       :after evil-collection
       :hook
       (after-init . global-evil-matchit-mode))
   #+end_src

** evil-exchange
   Port of =vim-exchange= used to exchange two text selections based on two
   consecutive motions beginning with =gx=.

   #+begin_src emacs-lisp
     (use-package evil-exchange
       :after evil-collection
       :demand t
       :config
       (evil-exchange-install))
   #+end_src

** evil-extra-operator
   #+begin_src emacs-lisp
     (use-package evil-extra-operator
       :demand t)
   #+end_src

** evil-args
   #+begin_src emacs-lisp
     (use-package evil-args
       :after evil-collection
       :bind
       (:map evil-inner-text-objects-map
             ("a" . evil-inner-arg)
             :map evil-outer-text-objects-map
             ("a" . evil-outer-arg)
             :map evil-normal-state-map
             ("C-c a l" . evil-forward-arg)
             ("C-c a h" . evil-backward-arg)
             ("C-c a k" . evil-jump-out-arg)
             :map evil-motion-state-map
             ("C-c a l" . evil-forward-arg)
             ("C-c a h" . evil-backward-arg)))
   #+end_src

** evil-visualstar
   #+begin_src emacs-lisp
     (use-package evil-visualstar
       :after evil-collection
       :hook
       (after-init . global-evil-visualstar-mode))
   #+end_src

** evil-snipe
   =evil-snipe= allows you to move around buffers a bit more flexibly using keys
   such as 'f', 'F', 's', and 'S'. See its GitHub page for more details.

   #+begin_src emacs-lisp
     (use-package evil-snipe
       ;; I prefer to use avy instead of snipe.
       :disabled
       :demand t
       :after (evil-leader evil-collection)
       :hook
       ;; Turn off snipe in magit-mode for compatibility.
       (magit-mode . turn-off-evil-snipe-override-mode)
       :custom
       (evil-snipe-scope 'whole-visible)
       (evil-snipe-repeat-scope 'whole-buffer)
       (evil-snipe-spillover-scope 'whole-buffer)
       :config
       ;; Don't want snipe messing with evil-leader's mappings.
       (define-key evil-snipe-override-mode-map (kbd "<motion-state> ,") nil)
       (define-key evil-snipe-override-local-mode-map (kbd "<motion-state> ,") nil)
       ;; Map '[' to match any opening delimiter in any snipe mode.
       (push '(?\[ "[[{(]") evil-snipe-aliases)
       (evil-snipe-override-mode 1))
   #+end_src

** evil-org
   #+begin_src emacs-lisp
     (use-package evil-org
       :demand t
       :after (org evil)
       :hook
       ((org-mode . evil-org-mode)
        (evil-org-mode . (lambda ()
                           (evil-org-set-key-theme))))
       :config
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys))
   #+end_src

** kubernetes-evil

   #+begin_src emacs-lisp
     (use-package kubernetes-evil
       :demand t
       :after (evil kubernetes))
   #+end_src

** lispyville
   Provides better integration between =evil-mode= and =lispy-mode=, which is a
   minor mode plugin for editing files written in LISP dialects.  Here are the
   main features of =lispyville=:

   - Provides “safe” versions of vim’s yank, delete, and change related
     operators that won’t unbalance parentheses.
   - Provides lisp-related evil operators, commands, motions, and text objects.
   - Integrates =evil= with =lispy= by providing commands to more easily switch
     between normal state and lispy’s “special” context/mode and by providing
     options for integrating visual state with lispy’s special region model

*** Functions
    #+begin_src emacs-lisp
      (defun my/set-lispyville-leader-keys ()
        "Set `evil-leader' keybindings for all lispy modes."
        (mapcar (lambda (mode)
                  (let ((evil-leader-lispy-keys-alist '(("l(" . lispyville-wrap-round)
                                                        ("l)" . lispyville-wrap-round)
                                                        ("l[" . lispyville-wrap-brackets)
                                                        ("l]" . lispyville-wrap-brackets)
                                                        ("l{" . lispyville-wrap-braces)
                                                        ("l}" . lispyville-wrap-braces)
                                                        ("l<" . lispyville-barf)
                                                        ("l>" . lispyville-slurp)
                                                        ("lC" . lispy-convolute-sexp)
                                                        ("lD" . lispy-describe-inline)
                                                        ("lO" . lispy-oneline)
                                                        ("lR" . lispyville-raise-list)
                                                        ("lS" . lispy-splice)
                                                        ("ld" . evil-collection-lispy-delete)
                                                        ("lj" . lispy-join)
                                                        ("lm" . lispy-multiline)
                                                        ("ln" . lispy-left)
                                                        ("lo" . lispy-string-oneline)
                                                        ("lp" . lispy-clone)
                                                        ("lr" . lispy-raise-sexp)
                                                        ("ls" . lispy-split)
                                                        ("lt" . transpose-sexps)
                                                        ("ly" . lispy-new-copy))))
                    (mapcar (lambda (element)
                              (let ((key (car element))
                                    (fun (cdr element)))
                                (evil-leader/set-key-for-mode mode key fun)))
                            evil-leader-lispy-keys-alist)))
                my/lisp-major-modes)
        t)

      (defun my/set-lispyville-mode-keys ()
        "Set extra `evil-mode' keybindings for `lispyville-mode'."
        (let ((keymap lispyville-mode-map))
          (evil-define-key 'normal keymap
            ;; slurp: expand current s-exp; barf: Contract current s-exp
            "-" #'lispyville-slurp
            "_" #'lispyville-barf
            ;; Split and join s-exps
            "\\" #'lispy-split
            "|" #'lispy-join
            ;; Delimiter navigation
            "{" #'lispyville-previous-opening
            "}" #'lispyville-next-closing
            ;; List navigation
            "(" #'lispyville-backward-up-list
            ")" #'lispyville-up-list
            ;; Use H and L to move across s-exps
            "H" #'lispyville-backward-sexp
            "L" #'lispyville-forward-sexp
            ;; Make "J" into the safe join operator in Lisp modes
            "J" #'lispyville-join
            ;; Special comment functions
            "gcc" #'lispyville-comment-or-uncomment-line
            "gcC" #'lispyville-comment-or-uncomment
            "gcy" #'lispyville-comment-and-clone-dwim
            ;; Mark symbols with M-m
            (kbd "M-m") #'lispy-mark-symbol
            ;; Contract/expand current sexp.
            "<<" #'lispyville-barf
            ">>" #'lispyville-slurp)
          (evil-define-key '(normal insert) keymap
            ;; Function navigation
            (kbd "M-h") #'lispyville-beginning-of-defun
            (kbd "M-l") #'lispyville-end-of-defun)
          (evil-define-key 'visual keymap
            "gc" #'lispyville-comment-or-uncomment-line
            "gC" #'lispyville-comment-or-uncomment
            "gy" #'lispyville-comment-and-clone-dwim)
          (evil-define-key '(normal insert visual) keymap
            (kbd "M-;") #'lispy-comment)))
    #+end_src

*** use-package specification
    #+begin_src emacs-lisp
      (use-package lispyville
        :after (evil-collection lispy)
        :hook
        (lispy-mode . lispyville-mode)
        :bind
        (:map evil-collection-lispy-mode-map
              ;; Get rid of "[" and "]" bindings in lispy-mode so that we can use
              ;; unimpaired bindings.
              ("<normal-state> [" . nil)
              ("<normal-state> ]" . nil)
              ;; Remove default barf/slurp keybindings.
              ("<normal-state> <" . nil)
              ("<normal-state> >" . nil))
        :custom
        ;; Setting this variable to t means lispyville motion commands, such as (, ),
        ;; {, }, etc.  automatically enter insert mode to make editing more fluid.
        (lispyville-motions-put-into-special nil)
        ;; The preferred state for editing text in lispyville mode.
        ;; Can be either 'insert or 'emacs.
        (lispyville-preferred-lispy-state 'insert)
        :config
        ;; Change default keybindings for lispyville.
        (lispyville-set-key-theme '(;; Standard evil operator remappings
                                    operators
                                    ;; Safe backward word delete
                                    c-w
                                    ;; Safe delete back to indent
                                    c-u
                                    ;; Enter normal mode and deactivate region in one
                                    ;; step.
                                    escape
                                    ;; <i and >i insert at beginning and end of sexp
                                    arrows
                                    ;; evil-indent now prettifies expressions
                                    prettify
                                    ;; Use M-(, M-{, and M-[ to wrap Lisp objects in
                                    ;; delimiters.
                                    wrap
                                    ;; Use W, B, E, and gE to move semantically across
                                    ;; Lisp objects.
                                    (atom-movement t)
                                    ;; Extra text object motions
                                    text-objects
                                    ;; Extra bindings
                                    additional))
        ;; Only use evil-mode's visual selection instead of lispy marks.
        (lispyville-enter-visual-when-marking)
        (advice-add 'lispyville-yank :around 'my/highlight-evil-region-advice)
        (my/set-lispyville-mode-keys)
        (my/set-lispyville-leader-keys)
        ;; Add lispyville special mode indicator to modeline.
        (add-to-list 'mode-line-misc-info
                     '(:eval (when (featurep 'lispyville)
                               (lispyville-mode-line-string)))))
    #+end_src
