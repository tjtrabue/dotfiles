#+title:  evil-mode Configuration
#+author: Tom Trabue
#+email:  tom.trabue@gmail.com
#+date:   2020:05:25
#+STARTUP: fold

The Extensible VI Layer (AKA evil.  AKA the only way to use Emacs).
=evil-mode= is a fully featured VI emulator for Emacs, even improving upon the
features of Vim at times.

*If Evil Mode treats 'd' like 'dd', 'c' like 'cc', etc*: You need delete the
\*Backtrace\* buffer!!! This problem has been plaguing me since day 1 of using
Evil, and I hate it! If deleting \*Backtrace\* doesn't work, there's probably
some other buffer you need to delete to get Evil working again. Remember, you
can turn off automatic error debugging by changing the =debug-on-error= variable
to =nil=, so this may help you.

* Define custom evil operators
  An =evil-operator= is a function that acts on text objects (characters, words,
  lines, etc.). They are designed to mimic Vim's operators.

  #+begin_src emacs-lisp
    (eval-when-compile
      (unless (fboundp 'my/define-custom-evil-operators)
        (defun my/define-custom-evil-operators ()
          "Define extra operators for use in `evil-mode'."

          ;; FIXME
          ;; when done on line:
          ;;     (insert "\n#endif  // " ident)))))
          ;; it modifies the string and becomes:
          ;;     (insert "\n#endif // " ident)))))
          ;;
          ;; if joined lines are comments, remove delimiters
          (evil-define-operator my-evil-join (beg end)
            "Join the selected lines. Based on blaenk/dots on GitHub.

    This custom version of `evil-join' handles joining commented
    lines more handily than evil's default J operator, removing
    leading comment designators. In that sense, it behaves far more
    like Vim."
            :motion evil-line
            (let* ((count (count-lines beg end))
                   ;; we join pairs at a time
                   (count (if (> count 1) (1- count) count))
                   ;; the mark at the middle of the joined pair of lines
                   (fixup-mark (make-marker)))
              (dotimes (var count)
                (if (and (bolp) (eolp))
                    (join-line 1)
                  (let* ((end (line-beginning-position 3))
                         (fill-column (1+ (- end beg))))
                    ;; save the mark at the middle of the pair
                    (set-marker fixup-mark (line-end-position))
                    ;; join it via fill
                    (fill-region-as-paragraph beg end)
                    ;; jump back to the middle
                    (goto-char fixup-mark)
                    ;; context-dependent whitespace fixup
                    (fixup-whitespace))))
              ;; remove the mark
              (set-marker fixup-mark nil))))))
  #+end_src

* Custom advice functions
  Evil mode functions will call these advice functions back automatically based
  on their parameters.

** Define advice functions
   #+begin_src emacs-lisp
     (eval-when-compile
       (defun my/highlight-evil-region-advice (orig-fn beg end &rest args)
         "Pulse a selected buffer region with a highlight for a moment."
         (pulse-momentary-highlight-region beg end 'highlight)
         (apply orig-fn beg end args)))
   #+end_src

** Add advice to evil functions
   #+begin_src emacs-lisp
     (defun my/add-evil-advice ()
       "Add advice to various `evil-mode' functions."
       (advice-add 'evil-yank :around 'my/highlight-evil-region-advice))
   #+end_src

* Other functions
  Miscellaneous functions related to =evil-mode=.

  #+begin_src emacs-lisp
    (defun my/set-evil-keybindings ()
      "Set VI-like keybindings for various major modes."
      ;; Use custom "J" command that removes leading comment designators.
      (define-key evil-normal-state-map [remap evil-join] 'my-evil-join)
      ;; Evil ":" command minibuffer keys
      (evil-define-key 'insert evil-ex-completion-map
        (kbd "<tab>") #'evil-ex-completion
        (kbd "TAB") #'evil-ex-completion))

    (defun my/set-evil-leader-shortcuts ()
      "Define leader shortcuts for `evil-mode' similar to Vim's leader feature."
      (my/evil-leader-def
        ;; M-x alias
        "," 'execute-extended-command
        ;; Evil line navigation
        "m" 'evil-first-non-blank
        "." 'evil-end-of-line
        ;; Buffer
        "bb" 'switch-to-buffer
        "bk" 'kill-this-buffer
        ;; Dired
        "dd" 'dired
        ;; eshell
        "es" 'eshell-below
        ;; Git/Magit
        "gg" 'magit-status
        "gd" 'magit-dispatch
        "gtt" 'git-timemachine-toggle
        ;; ace-window
        "jk" 'ace-window
        ;; Killing buffers
        "kk" 'kill-buffer
        ;; File
        "lf" 'load-file
        "of" 'org-babel-load-file
        ;; Flycheck
        "fn" 'flycheck-next-error
        "fp" 'flycheck-previous-error
        ;; File searching
        "rg" 'deadgrep
        ;; undo-tree
        ;; "ut" #'undo-tree-visualize
        ))
  #+end_src

* =use-package= specification
  The Evil mode plugin itself.

  *NOTE*: If you want to use =evil-leader=, you need to load =evil-leader=
  /before/ loading =evil=. What's more, you need to set all evil variables in
  =evil-leader='s =use-package= specification instead of =evil='s since
  =evil-leader= will set them to default values otherwise.

  #+begin_src emacs-lisp
    (use-package evil
      :demand t
      :general
      ;; Use "jk" to escape from insert and replace states.
      ;; We need to use the full `general-define-key' function instead of
      ;; `general-def' because we want to use the evaluated output of
      ;; `general-chord' in our key definitions.
      (general-define-key :states '(insert, replace)
                          (general-chord "jk") 'evil-normal-state)
      ;; `general-def' if a shorthand macro wrapper for `general-define-key' that
      ;; allows using positional parameters for evil states and keymaps.
      ;; Its usage is as follows:
      ;;
      ;;   (general-def [evil states] [keymap] key def ...)
      ;;
      ;; where elements in [] are optional but must appear in the specified order.
      (general-def 'normal
        ;; Use the good old Vim commands to move the cursor to the top or bottom of
        ;; the window.
        "H" 'evil-window-top
        "L" 'evil-window-bottom
        ;; I like this shortcut for switching buffers.
        "C-e" 'switch-to-buffer
        ;; Only scroll half a page up/down with C-b and C-f instead of a
        ;; full page. I find this gives me more control over page movement.
        [remap evil-scroll-page-up] 'evil-scroll-up
        [remap evil-scroll-page-down] 'evil-scroll-down)
      (general-def 'insert
        ;; TAB should try expanding or fall back on self-insertion.
        "TAB" 'my-hippie-expand-or-insert-tab
        "<tab>" 'my-hippie-expand-or-insert-tab)
      ;; This form unbinds keys in given evil states and/or keymaps.
      (general-unbind 'insert
        ;; Get rid of annoying evil-paste-from-register binding.
        "C-r")
      :init
      ;; NOTE: We must set variables for evil-mode's initialization in evil-leader's
      ;;       use-package directive because it loads first, and it in turn loads
      ;;       evil mode. That is, if we're using `evil-leader'. If not, list them
      ;;       here.

      ;; Set evil-mode variables here.
      ;; These values must be set here because evil-leader loads before evil
      ;; itself. Thus, these variables will have already been set by the time
      ;; Evil's use-package specification loads, making any variable definitions
      ;; set there useless.
      ;;
      ;; Tell Evil that 'Y' in normal state yanks from point to the end of line
      ;; as opposed to the entire line like 'yy'.
      (setq evil-want-Y-yank-to-eol t)
      ;; Need this for evil-collection; loads evil-integration.el
      (setq evil-want-integration t)
      ;; Do not use any default keybinding since evil-collection
      ;; takes care of that part.
      (setq evil-want-keybinding nil)
      ;; Which search library to use for '/' and '?'.
      ;; Defaults to 'isearch, but 'evil-search is a bit better.
      (setq evil-search-module 'evil-search)
      ;; Make '>>' and '<<' commands indent according to Emacs' tab width.
      (setq-default evil-shift-width tab-width
                    ;; '>>' and '<<' should round indent to the next nearest tab stop.
                    evil-shift-round t)
      :config
      ;; Enable evil-mode globally
      (evil-mode 1)
      (my/define-custom-evil-operators)
      (my/add-evil-advice)
      (my/set-evil-keybindings)
      (my/set-evil-leader-shortcuts))
  #+end_src

* Plugins
** evil-leader
   =evil-leader= is an emulator for Vim's mapleader feature allowing users to
   define key bindings based on pressing a leader key (usually comma) followed
   by an arbitrary succession of additional key strokes to call a predefined
   function. It's similar in nature to Emacs' =key-chord= plugin.

   *NOTE:* =general= provides a better method for defining Emacs keybindings in
   general (no pun intended), including leader-like keybindings. Not only this,
   but =evil-leader= is, unfortunately, quite badly documented. =general=, on
   the other hand, is one of the best documented Emacs plugins I've ever
   seen. For these reasons, I recommend using =general= and foregoing
   =evil-leader= altogether.

   #+begin_src emacs-lisp
     (use-package evil-leader
       ;; Disabled in favor of general.
       :disabled
       :demand t
       :hook
       (after-init . global-evil-leader-mode)
       :init
       ;; Set evil-mode variables here.
       ;; These values must be set here because evil-leader loads before evil
       ;; itself. Thus, these variables will have already been set by the time
       ;; Evil's use-package specification loads, making any variable definitions
       ;; set there useless.
       ;;
       ;; Tell Evil that 'Y' in normal state yanks from point to the end of line
       ;; as opposed to the entire line like 'yy'.
       (setq evil-want-Y-yank-to-eol t
             ;; Need this for evil-collection; loads evil-integration.el
             evil-want-integration t
             ;; Do not use any default keybinding since evil-collection
             ;; takes care of that part.
             evil-want-keybinding nil)
       ;; Make '>>' and '<<' commands indent according to Emacs' tab width.
       (setq-default evil-shift-width tab-width
                     ;; '>>' and '<<' should round indent to the next nearest tab stop.
                     evil-shift-round t)
       :custom
       (evil-leader/leader ",")
       :config
       (evil-leader/set-key
        ;; M-x alias
        "," #'execute-extended-command
        ;; Evil line navigation
        "m" #'evil-first-non-blank
        "." #'evil-end-of-line
        ;; Buffer
        "bb" #'switch-to-buffer
        "bk" #'kill-this-buffer
        ;; Dired
        "dd" #'dired
        ;; eshell
        "es" #'eshell-below
        ;; Git/Magit
        "gg" #'magit-status
        "gd" #'magit-dispatch
        "gtt" #'git-timemachine-toggle
        ;; ace-window
        "jk" #'ace-window
        ;; Killing buffers
        "kk" #'kill-buffer
        ;; File
        "lf" #'load-file
        "of" #'org-babel-load-file
        ;; Flycheck
        "fn" #'flycheck-next-error
        "fp" #'flycheck-previous-error
        ;; File searching
        "rg" #'deadgrep
        ;; undo-tree
        ;; "ut" #'undo-tree-visualize
        ))
   #+end_src

** evil-collection
   Used to provide default Vim keybindings for all standard Emacs modes.
   #+begin_src emacs-lisp
     (use-package evil-collection
       :after evil
       :demand t
       :general
       (general-unbind 'normal
         ;; Unbind some unused mappings
         "M-.")
       :custom
       ;; Whether or not to use Vim keys in the minibuffer.
       (evil-collection-setup-minibuffer t)
       :config
       (evil-collection-init)
       ;; Get rid of troublesome keybindings (must come here in the :config block):
       ;; We do not need to kill a line with C-k anymore since we're using
       ;; Vim keys.
       (global-unset-key (kbd "C-k"))
       ;; We never need to insert digraphs!
       (define-key evil-insert-state-map (kbd "C-k") nil))
   #+end_src

** evil-escape
   Use key sequences to /escape/ from stock evil states and return to evil's
   normal state. This allows us to do things like typing "jk" to return to
   evil's normal state from insert state.

   #+begin_src emacs-lisp
     (use-package evil-escape
       ;; Using key-chord seems to work better.
       :disabled
       :after evil-collection
       :demand t
       :custom
       ;; The key sequence used to return to evil's normal state.
       (evil-escape-key-sequence "jk")
       ;; How long after the last key press evil-escape should wait before performing
       ;; the key's default function.
       ;; Default: 0.1
       ;; You should probably set this to 0.2 if your escape key sequence is the same
       ;; character typed twice in a row.
       (evil-escape-delay 0.1)
       :config
       ;; Activate evil-escape globally.
       (evil-escape-mode +1))
   #+end_src

** evil-surround
   #+begin_src emacs-lisp
     (use-package evil-surround
       :after evil-collection
       :hook
       (after-init . global-evil-surround-mode))
   #+end_src

** evil-numbers
   #+begin_src emacs-lisp
     (use-package evil-numbers
       :demand t
       :config
       (define-key evil-normal-state-map (kbd "C-c +") 'evil-numbers/inc-at-pt)
       (define-key evil-normal-state-map (kbd "C-c -") 'evil-numbers/dec-at-pt))
   #+end_src

** evil-commentary
   Code commenting plugin based on =vim-commentary= for Vim.

   #+begin_src emacs-lisp
     (use-package evil-commentary
       ;; Disabled in favor of evil-nerd-commenter
       :disabled
       :after evil-collection
       :hook
       (after-init . evil-commentary-mode))
   #+end_src

** evil-nerd-commenter
   A powerful and configurable code commenting plugin based on =NerdCommenter=
   for Vim. Unlike =evil-commentary=, this plugin does not come with any default
   keybindings. You must assign them as you see fit, and I just so happen to
   have my keybindings set up to mirror =evil-commentary='s default
   configuration.

   #+begin_src emacs-lisp
     (use-package evil-nerd-commenter
       :after evil-collection
       :general
       (general-def 'normal 'override
         "g c c" 'evilnc-comment-or-uncomment-lines
         "g c l" 'evilnc-quick-comment-or-uncomment-to-the-line
         "g c p" 'evilnc-comment-or-uncomment-paragraphs
         "g c r" 'comment-or-uncomment-region)
       (general-def 'visual 'override
         "g c" 'evilnc-comment-or-uncomment-lines
         "g C" 'comment-or-uncomment-region))
   #+end_src

** evil-mark-replace
   Replace symbol at point in marked area. This plugin is not terribly useful,
   given the advent of powerful IDE plugins such as =lsp-mode=, but it still may
   be marginally useful at times.

   #+begin_src emacs-lisp
     (use-package evil-mark-replace
       :disabled
       :after evil-collection
       :demand t)
   #+end_src

** evil-matchit
   #+begin_src emacs-lisp
     (use-package evil-matchit
       :after evil-collection
       :hook
       (after-init . global-evil-matchit-mode))
   #+end_src

** evil-exchange
   Port of =vim-exchange= used to exchange two text selections based on two
   consecutive motions beginning with =gx=.

   #+begin_src emacs-lisp
     (use-package evil-exchange
       :after evil-collection
       :demand t
       :config
       (evil-exchange-install))
   #+end_src

** evil-extra-operator
   #+begin_src emacs-lisp
     (use-package evil-extra-operator
       :demand t)
   #+end_src

** evil-args
   #+begin_src emacs-lisp
     (use-package evil-args
       :after evil-collection
       :general
       (general-def 'normal
         "C-c a l" 'evil-forward-arg
         "C-c a h" 'evil-backward-arg
         "C-c a k" 'evil-jump-out-arg)
       (general-def 'motion
         "C-c a l" 'evil-forward-arg
         "C-c a h" 'evil-backward-arg)
       (general-def evil-inner-text-objects-map
         "a" 'evil-inner-arg)
       (general-def evil-outer-text-objects-map
         "a" 'evil-outer-arg))
   #+end_src

** evil-visualstar
   #+begin_src emacs-lisp
     (use-package evil-visualstar
       :after evil-collection
       :hook
       (after-init . global-evil-visualstar-mode))
   #+end_src

** evil-snipe
   =evil-snipe= allows you to move around buffers a bit more flexibly using keys
   such as 'f', 'F', 's', and 'S'. See its GitHub page for more details.

   #+begin_src emacs-lisp
     (use-package evil-snipe
       ;; I prefer to use avy instead of snipe.
       :disabled
       :demand t
       :after evil-collection
       :hook
       ;; Turn off snipe in magit-mode for compatibility.
       (magit-mode . turn-off-evil-snipe-override-mode)
       :custom
       (evil-snipe-scope 'whole-visible)
       (evil-snipe-repeat-scope 'whole-buffer)
       (evil-snipe-spillover-scope 'whole-buffer)
       :config
       ;; Don't want snipe messing with evil-leader's mappings.
       (define-key evil-snipe-override-mode-map (kbd "<motion-state> ,") nil)
       (define-key evil-snipe-override-local-mode-map (kbd "<motion-state> ,") nil)
       ;; Map '[' to match any opening delimiter in any snipe mode.
       (push '(?\[ "[[{(]") evil-snipe-aliases)
       (evil-snipe-override-mode 1))
   #+end_src

** evil-org
   #+begin_src emacs-lisp
     (use-package evil-org
       :demand t
       :after (org evil)
       :hook
       ((org-mode . evil-org-mode)
        (evil-org-mode . (lambda ()
                           (evil-org-set-key-theme))))
       :config
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys))
   #+end_src

** evil-mc
   Multiple cursors implementation for =evil-mode=. This package does not depend
   on =multiple-cursors= at all, and is in fact an alternative implementation.

   #+begin_src emacs-lisp
     (use-package evil-mc
       :after evil-collection
       :demand t
       :general
       (general-def '(normal visual)
         "C->" 'evil-mc-make-and-goto-next-match
         "C-<" 'evil-mc-make-and-goto-prev-match)
       ;; Set leader shortcuts
       (my/evil-leader-def
         "cA" 'evil-mc-make-all-cursors
         "cU" 'evil-mc-undo-all-cursors
         "cn" 'evil-mc-make-and-goto-next-match
         "cp" 'evil-mc-make-and-goto-prev-match
         "cu" 'evil-mc-undo-last-added-cursor)
       :custom
       ;; Override default mode line string
       (evil-mc-mode-line-prefix "ⓜ")
       :config
       (global-evil-mc-mode 1))
   #+end_src

** kubernetes-evil
   #+begin_src emacs-lisp
     (use-package kubernetes-evil
       :demand t
       :after (evil kubernetes))
   #+end_src

** lispyville
   Provides better integration between =evil-mode= and =lispy-mode=, which is a
   minor mode plugin for editing files written in LISP dialects.  Here are the
   main features of =lispyville=:

   - Provides “safe” versions of vim’s yank, delete, and change related
     operators that won’t unbalance parentheses.
   - Provides lisp-related evil operators, commands, motions, and text objects.
   - Integrates =evil= with =lispy= by providing commands to more easily switch
     between normal state and lispy’s “special” context/mode and by providing
     options for integrating visual state with lispy’s special region model

*** Functions
    #+begin_src emacs-lisp
      (defun my/lispyville-wrap-round-and-insert (arg)
        "Call `lispy-parens' with a default ARG of 1 and enter `evil-insert-state'."
        (interactive "P")
        (lispy-parens (or arg 1))
        (evil-insert-state))

      (defun my/set-lispyville-leader-keys ()
        "Set `evil-leader' keybindings for all lispy modes."
        (mapc (lambda (mode)
                (let ((mode-map (intern (concat (symbol-name mode) "-map"))))
                  ;; Here we use the :keymaps keyword argument because we want to
                  ;; evaluate `mode-map' before passing it to `my/evil-leader-def'.
                  (my/evil-leader-def :keymaps mode-map
                    "l(" 'lispy-wrap-round
                    "l)" 'lispyville-wrap-round
                    "l[" 'lispy-wrap-brackets
                    "l]" 'lispyville-wrap-brackets
                    "l{" 'lispy-wrap-braces
                    "l}" 'lispyville-wrap-braces
                    "l<" 'lispyville-<
                    "l>" 'lispyville->
                    "lC" 'lispy-convolute-sexp
                    "lD" 'lispy-describe-inline
                    "lE" 'lispy-eval-and-insert
                    "lO" 'lispy-string-oneline
                    "lQ" 'lispy-quotes
                    "lR" 'lispyville-raise-list
                    "lS" 'lispy-splice
                    "lU" 'lispy-unbind-variable
                    "lb" 'lispy-bind-variable
                    "lc" 'lispy-clone
                    "ld" 'evil-collection-lispy-delete
                    "le" 'lispy-eval
                    "lj" 'lispy-join
                    "lm" 'lispy-multiline
                    "ln" 'lispy-left
                    "lo" 'lispy-oneline
                    "lp" 'lispy-tab
                    "lq" 'lispy-stringify
                    "lr" 'lispy-raise-sexp
                    "ls" 'lispy-split
                    "lt" 'transpose-sexps
                    "lw" 'my/lispyville-wrap-round-and-insert
                    "ly" 'lispy-new-copy)))
              my/lisp-major-modes)
        t)

      (defun my/set-lispyville-mode-keys ()
        "Set extra `evil-mode' keybindings for `lispyville-mode'."
        (let ((keymap lispyville-mode-map))
          (evil-define-key 'normal keymap
            ;; slurp: expand current s-exp; barf: Contract current s-exp
            "-" #'lispyville-slurp
            "_" #'lispyville-barf
            ;; Split and join s-exps
            "\\" #'lispy-split
            "|" #'lispy-join
            ;; Delimiter navigation
            "{" #'lispyville-previous-opening
            "}" #'lispyville-next-closing
            ;; List navigation
            "(" #'lispyville-backward-up-list
            ")" #'lispyville-up-list
            ;; Make "J" into the safe join operator in Lisp modes
            "J" #'lispyville-join
            ;; Adapt ace-style jump commands for lispy.
            "F" #'lispy-ace-paren
            ;; Special comment functions
            "gcc" #'lispyville-comment-or-uncomment-line
            "gcC" #'lispyville-comment-or-uncomment
            "gcy" #'lispyville-comment-and-clone-dwim
            ;; Mark symbols with M-m
            (kbd "M-m") #'lispy-mark-symbol)
          (evil-define-key '(normal insert) keymap
            ;; Function navigation
            (kbd "M-h") #'lispyville-beginning-of-defun
            (kbd "M-l") #'lispyville-end-of-defun)
          (evil-define-key '(normal visual) keymap
            ;; Contract/expand current sexp.
            "<<" #'lispyville-<
            ">>" #'lispyville->
            ;; Move s-exps back and forth
            (kbd "M-j") #'lispyville-move-down
            (kbd "M-k") #'lispyville-move-up)
          (evil-define-key 'visual keymap
            "gc" #'lispyville-comment-or-uncomment-line
            "gC" #'lispyville-comment-or-uncomment
            "gy" #'lispyville-comment-and-clone-dwim)
          (evil-define-key '(normal insert visual) keymap
            (kbd "M-;") #'lispy-comment)))

      (defun my/set-lispyville-lispy-keys ()
        "Use `lispy-define-key' to set extra keybindings for `lispyville'."
        ;; Use "v" to enter lispy special while in Evil's visual state.
        (lispy-define-key lispy-mode-map "v" #'lispyville-toggle-mark-type))
    #+end_src

*** =use-package= specification
    #+begin_src emacs-lisp
      (use-package lispyville
        :after (evil-collection lispy)
        :hook
        (lispy-mode . lispyville-mode)
        :general
        (general-unbind 'normal evil-collection-lispy-mode-map
          ;; Get rid of "[" and "]" bindings in lispy-mode so that we can use
          ;; unimpaired bindings.
          "["
          "]"
          ;; Remove default barf/slurp keybindings.
          "<"
          ">")
        :custom
        ;; Setting this variable to t means lispyville motion commands, such as (, ),
        ;; {, }, etc.  automatically enter insert mode to make editing more fluid.
        (lispyville-motions-put-into-special nil)
        ;; The preferred state for editing text in lispyville mode.
        ;; Can be either 'insert or 'emacs.
        (lispyville-preferred-lispy-state 'insert)
        :config
        ;; Change default keybindings for lispyville.
        (lispyville-set-key-theme '(;; Standard evil operator remappings
                                    operators
                                    ;; Safe backward word delete
                                    c-w
                                    ;; Safe delete back to indent
                                    c-u
                                    ;; Enter normal mode and deactivate region in one
                                    ;; step.
                                    escape
                                    ;; <i and >i insert at beginning and end of sexp
                                    arrows
                                    ;; evil-indent now prettifies expressions
                                    prettify
                                    ;; Use M-(, M-{, and M-[ to wrap Lisp objects in
                                    ;; delimiters.
                                    wrap
                                    ;; Use W, B, E, and gE to move semantically across
                                    ;; Lisp objects.
                                    (atom-movement t)
                                    ;; Extra text object motions
                                    text-objects
                                    ;; Extra bindings
                                    additional
                                    ;; Integrates visual state with lispy-mark
                                    ;; commands.
                                    ;; v -> wrapped lispy-mark-symbol
                                    ;; V -> wrapped lispy-mark
                                    ;; C-v -> wrapped lispy-mark
                                    ;; mark
                                    ;; Use v to toggle mark.
                                    ;; NOTE: This will alter the behavior of `mark'.
                                    ;; mark-toggle
                                    ))
        ;; Only use evil-mode's visual selection instead of lispy marks.
        (lispyville-enter-visual-when-marking)
        (advice-add 'lispyville-yank :around 'my/highlight-evil-region-advice)
        (my/set-lispyville-mode-keys)
        (my/set-lispyville-leader-keys)
        ;; (my/set-lispyville-lispy-keys)
        ;; Add lispyville special mode indicator to modeline.
        (add-to-list 'mode-line-misc-info
                     '(:eval (when (featurep 'lispyville)
                               (lispyville-mode-line-string)))))
    #+end_src
