#+title:  Clojure Configuration/Plugins
#+author: Tom Trabue
#+email:  tom.trabue@gmail.com
#+date:   2020:05:25
#+STARTUP: fold

Integration for the awesome Clojure programming language.  Thanks, Rich! The
world needed another Lisp.

* clojure-mode
  Major mode for editing Clojure files.

  #+begin_src emacs-lisp
    (use-package clojure-mode
      :straight
      ;; Default straight recipe only includes the clojure-mode.el file for some
      ;; reason.
      (clojure-mode :type git :host github :repo "clojure-emacs/clojure-mode"
                    :files (:defaults))
      :config
      ;; Add extra syntax coloring (imprecise, but pretty)
      (require 'clojure-mode-extra-font-locking))
  #+end_src

* CIDER
  An /extremely/ powerful IDE for Clojure similar to SLIME or SLY for Common
  Lisp.

  To start the CIDER REPL server, press =C-c C-x j j= or =C-c M-j= from inside a
  Clojure buffer.

** CIDER's Performance
   CIDER is a powerful IDE server for Emacs (or potentially any editor that
   decides to implement CIDER's nREPL specification), but there are situations
   where it can be sluggish. You know what I mean: either the REPL lags after an
   input, or a keyboard shortcut that sends new code to CIDER hangs for an
   extended period of time. These problems are common, but are also quite
   fixable. Here a few tips for how to speed up CIDER.

*** Update CIDER
    Make sure you are running the latest version of CIDER. Performance issues
    are fixed frequently.

*** Wait a while after startup
    Plain and simple. After CIDER starts up, wait a minute or two before
    interacting with it. I've found that sometimes CIDER needs a moment to
    startup fully.

** Variables
   #+begin_src emacs-lisp
     (defvar my/extra-cider-jack-in-deps '(("zprint" . "1.1.2"))
       "AList of extra dependencies for CIDER to install upon jack-in.")
   #+end_src

** Functions
  #+begin_src emacs-lisp
    (defun my/get-cider-lein-artifact-exclusions (exclusions)
      "Return an exclusions vector described by the elements of EXCLUSIONS."
      (if exclusions
          (format " :exclusions [%s]" (mapconcat #'identity exclusions " "))
        ""))

    (defun my/get-list-as-lein-artifact (lein-artifact-alist &optional exclusions)
      "Turn LEIN-ARTIFACT-ALIST into a shell-quoted string representing a lein artifact.
    Can specificy an optional EXCLUSIONS list, as well."
      (let ((dep (car lein-artifact-alist))
            (dep-version (cdr lein-artifact-alist)))
        (shell-quote-argument
         (format "[%s %S%s]" dep dep-version
                 (my/get-cider-lein-artifact-exclusions exclusions)))))

    (defun my/get-cider-lein-deps ()
      "Return a shell-quoted string of all extra lein dependencies for CIDER."
      (let ((dep-designator "update-in :dependencies conj ")
            (arg-separator " -- "))
        (seq-reduce (lambda (acc element)
                      (concat acc
                              dep-designator
                              (my/get-list-as-lein-artifact element)
                              arg-separator))
                    my/extra-cider-jack-in-deps
                    "")))

    (defun my/get-cider-lein-parameters ()
      "Return string of paramters to pass to lein."
      (let ((default-params "repl :headless :host localhost"))
        (concat (my/get-cider-lein-deps) default-params)))

    (defun my/cider-test-prompt-for-filters ()
      "Interactively prompt user for filters to apply to a test run."
      (interactive)
      (cider-test-run-loaded-tests 'prompt-for-filters))
  #+end_src

** =use-package= specification
  #+begin_src emacs-lisp
    (use-package cider
      :after evil-collection
      :hook
      (clojure-mode . cider-mode)
      :general
      (general-unbind cider-repl-mode-map
        ",")
      (general-def 'normal cider-repl-mode-map
        "C-j" 'cider-repl-next-input
        "C-k" 'cider-repl-previous-input
        "C-r" 'cider-repl-history)
      (general-def 'insert cider-repl-mode-map
        "C-r" 'cider-repl-history)
      (my/evil-leader-def cider-repl-mode-map
        "cs" 'cider-repl-handle-shortcut
        "cC" 'cider-classpath
        "cF" 'cider-repl-toggle-clojure-font-lock
        "cH" 'cider-repl-history
        "cN" 'cider-ns-reload
        "cR" 'cider-ns-refresh
        "cS" 'cider-sideloader-start
        "cU" 'cider-repl-require-repl-utils
        "ca" 'cider-restart
        "cb" 'cider-repl-clear-buffer
        "cc" 'cider-repl-clear-output
        "cd" 'cider-doc
        "ch" 'cider-repl-shortcuts-help
        "cn" 'cider-repl-set-ns
        "cp" 'cider-repl-toggle-pretty-printing
        "cq" 'cider-quit
        "cr" 'cider-run
        "cta" 'cider-test-run-loaded-tests
        "ctf" 'cider-test-run-ns-tests-with-filters
        "ctF" 'my/cider-test-prompt-for-filters
        "ctn" 'cider-test-run-ns-tests
        "ctp" 'cider-test-run-project-tests
        "ctr" 'cider-test-show-report
        "cu" 'cider-undef
        "cv" 'cider-version)
      (my/evil-leader-def cider-mode-map
        "=" 'cider-format-buffer)
      (general-def 'normal cider-mode-map
        "gs" 'cider-find-var
        "gi" 'cider-find-resource
        "gu" 'cider-xref-fn-refs)
      ;; Clearing the whole REPL is a useful feature since the REPL gets slower
      ;; the larger it gets.
      (my/user-leader-def cider-repl-mode-map
        "M-b" 'cider-repl-clear-buffer)
      :custom
      ;; Which printing function CIDER uses under the hood to print output.
      ;; pprint (default): clojure.pprint/pprint
      ;; pr:               clojure.core/pr
      ;; fipp:             Fast Idiomatic Pretty Printer, which is 5-10 times faster
      ;;                   than pprint. Probably the best default choice.
      ;; puget:            Puget is canonical serialization of data on top of fipp,
      ;;                   but is slightly slower.
      ;; zprint:           Fast and flexible alternative to the libraries mentioned
      ;;                   above. Highly configurable, but requires you to specify
      ;;                   zprint as a depdency either in your cider jack-in init
      ;;                   command, or in your project dependencies file.
      (cider-print-fn 'zprint)
      ;; Whether to show the very large help message when the CIDER REPL opens.
      ;; Turning it off saves space in the REPL buffer, which could speed up
      ;; performance in the beginning.
      (cider-repl-display-help-banner nil)
      ;; Set this to t if you want to see all debugging info for communication
      ;; between CIDER and the nREPL server in a buffer named *nrepl-messages
      ;; conn-name*. WARNING: This will greatly slow down CIDER!
      (nrepl-log-messages nil)
      ;; Whether to use font-locking for REPL input and results.
      (cider-repl-use-clojure-font-lock t)
      ;; How to colorize defined symbols of the following types.
      ;; Set this to nil to disable dynamic font-locking.
      ;; WARNING: Dynamic font-locking can slow down the REPL!
      (cider-font-lock-dynamically '(macro core function var))
      ;; (cider-font-lock-dynamically nil)
      ;; Whether to pretty-print REPL output
      (cider-repl-use-pretty-printing t)
      ;; Window startup behavior for the REPL.
      ;; 'display-only -> Do not focus the CIDER REPL when it starts up.
      (cider-repl-pop-to-buffer-on-connect 'display-only)
      ;; Prefix string for results of REPL evaluation
      (cider-repl-result-prefix " => ")
      ;; Set character size limit after which the REPL buffer will be trimmed.
      (cider-repl-buffer-size-limit 100000)
      ;; Wrap around REPL input history.
      (cider-repl-wrap-history t)
      ;; Max number of inputs held in history.
      (cider-repl-history-size 1000)
      ;; File for storing CIDER REPL history.
      (cider-repl-history-file
       (file-truename (concat user-emacs-directory "cider-repl-hist")))
      ;; Turn off hover documentation since lsp-mode provides a better alternative.
      (cider-eldoc-display-for-symbol-at-point nil)
      ;; CIDER will try to add expected function arguments based on the current
      ;; context (for example for the datomic.api/q function where it will show the
      ;; expected inputs of the query at point) if this is set to t
      (cider-eldoc-display-context-dependent-info t)
      ;; Whether to prefer local resources as opposed to remote, or TRAMP resouces,
      ;; if local resources are available.
      (cider-prefer-local-resources t)
      ;; Whether to save a file when CIDER loads its buffer.
      ;; 'prompt means to prompt, t means always save, nil means never save.
      (cider-save-file-on-load t)
      ;; Extra paramters to pass to lein, such as dependencies and plugins,
      ;; as well as the final repl command..
      (cider-lein-parameters (my/get-cider-lein-parameters)))
  #+end_src

* clj-refactor
  =clj-refactor= provides refactoring support for Clojure projects. It
  complements the refactoring functionality you'd find in =clojure-mode= and
  CIDER.

  #+begin_src emacs-lisp
    (use-package clj-refactor
      :hook
      (clojure-mode .
                    (lambda ()
                      (clj-refactor-mode 1)
                      ;; This choice of keybinding leaves cider-macroexpand-1
                      ;; unbound
                      (cljr-add-keybindings-with-prefix "C-c C-m")))
      :custom
      ;; disable clj-refactor adding ns to blank files.
      ;; This is for interoperability with lsp-mode.
      ;; lsp-mode takes care of this task.
      (cljr-add-ns-to-blank-clj-files nil)
      ;; Whether to warn the user before parsing the AST.
      (cljr-warn-on-eval nil))
  #+end_src
