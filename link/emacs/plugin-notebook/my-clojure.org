#+title:  Clojure Configuration/Plugins
#+author: Tom Trabue
#+email:  tom.trabue@gmail.com
#+date:   2020:05:25
#+STARTUP: fold

Integration for the awesome Clojure programming language.  Thanks, Rich! The
world needed another Lisp.

* clojure-mode
  Major mode for editing Clojure files.

  #+begin_src emacs-lisp
    (use-package clojure-mode
      :straight
      ;; Default straight recipe only includes the clojure-mode.el file for some
      ;; reason.
      (clojure-mode :type git :host github :repo "clojure-emacs/clojure-mode"
                    :files (:defaults))
      :config
      ;; Add extra syntax coloring (imprecise, but pretty)
      (require 'clojure-mode-extra-font-locking))
  #+end_src

* CIDER
  An /extremely/ powerful IDE for Clojure similar to SLIME or SLY for Common
  Lisp.

  To start a CIDER REPL session, press =C-c C-x j j= from inside a Clojure
  buffer.

** Variables
   #+begin_src emacs-lisp
     (defvar my/extra-cider-jack-in-deps '(("zprint" . "1.1.2"))
       "AList of extra dependencies for CIDER to install upon jack-in.")
   #+end_src

** Functions
  #+begin_src emacs-lisp
    (defun my/set-cider-repl-keybindings ()
      "Hook function for setting keybindings in CIDER nREPL mode.
    Make sure to only run this function after 'sly-mrepl loads."
      (with-eval-after-load "cider-repl"
        ;; Get rid of horrendous "," shortcut
        (define-key cider-repl-mode-map (kbd ",") nil)
        ;; Standard evil-mode shortcuts.
        (evil-define-key '(normal insert) cider-repl-mode-map
          ;; Cycle command input history with C-j and C-k.
          (kbd "C-j") #'cider-repl-next-input
          (kbd "C-k") #'cider-repl-previous-input
          ;; Browse REPL input history.
          (kbd "C-r") #'cider-repl-history)
        ;; Define useful evil-leader shortcuts.
        (evil-leader/set-key-for-mode 'cider-repl-mode
          "," #'cider-repl-handle-shortcut)
        ;; Clearing the whole REPL is a useful feature since the REPL gets slower
        ;; the larger it gets.
        (define-key cider-repl-mode-map (kbd "C-c M-b") #'cider-repl-clear-buffer)))

    (defun my/get-cider-lein-artifact-exclusions (exclusions)
      "Return an exclusions vector described by the elements of EXCLUSIONS."
      (if exclusions
          (format " :exclusions [%s]" (mapconcat #'identity exclusions " "))
        ""))

    (defun my/get-list-as-lein-artifact (lein-artifact-alist &optional exclusions)
      "Turn LEIN-ARTIFACT-ALIST into a shell-quoted string representing a lein artifact.
    Can specificy an optional EXCLUSIONS list, as well."
      (let ((dep (car lein-artifact-alist))
            (dep-version (cdr lein-artifact-alist)))
        (shell-quote-argument
         (format "[%s %S%s]" dep dep-version
                 (my/get-cider-lein-artifact-exclusions exclusions)))))

    (defun my/get-cider-lein-deps ()
      "Return a shell-quoted string of all extra lein dependencies for CIDER."
      (let ((dep-designator "update-in :dependencies conj ")
            (arg-separator " -- "))
        (seq-reduce (lambda (acc element)
                      (concat acc
                              dep-designator
                              (my/get-list-as-lein-artifact element)
                              arg-separator))
                    my/extra-cider-jack-in-deps
                    "")))

    (defun my/get-cider-lein-parameters ()
      "Return string of paramters to pass to lein."
      (let ((default-params "repl :headless :host localhost"))
        (concat (my/get-cider-lein-deps) default-params)))
  #+end_src

** =use-package= specification
  #+begin_src emacs-lisp
    (use-package cider
      :after evil-collection
      :hook
      (clojure-mode . cider-mode)
      :custom
      ;; Which printing function CIDER uses under the hood to print output.
      ;; pprint (default): clojure.pprint/pprint
      ;; pr:               clojure.core/pr
      ;; fipp:             Fast Idiomatic Pretty Printer, which is 5-10 times faster
      ;;                   than pprint. Probably the best default choice.
      ;; puget:            Puget is canonical serialization of data on top of fipp,
      ;;                   but is slightly slower.
      ;; zprint:           Fast and flexible alternative to the libraries mentioned
      ;;                   above. Highly configurable, but requires you to specify
      ;;                   zprint as a depdency either in your cider jack-in init
      ;;                   command, or in your project dependencies file.
      (cider-print-fn 'zprint)
      ;; Whether to show the very large help message when the CIDER REPL opens.
      (cider-repl-display-help-banner t)
      ;; Set this to t if you want to see all debugging info for communication
      ;; between CIDER and the nREPL server in a buffer named *nrepl-messages
      ;; conn-name*. WARNING: This will greatly slow down CIDER!
      (nrepl-log-messages nil)
      ;; Whether to use font-locking for REPL input and results.
      (cider-repl-use-clojure-font-lock t)
      ;; How to colorize defined symbols of the following types.
      ;; Set this to nil to disable dynamic font-locking.
      ;; WARNING: Dynamic font-locking can slow down the REPL!
      (cider-font-lock-dynamically '(macro core function var))
      ;; (cider-font-lock-dynamically nil)
      ;; Whether to pretty-print REPL output
      (cider-repl-use-pretty-printing t)
      ;; Window startup behavior for the REPL.
      ;; 'display-only -> Do not focus the CIDER REPL when it starts up.
      (cider-repl-pop-to-buffer-on-connect 'display-only)
      ;; Prefix string for results of REPL evaluation
      (cider-repl-result-prefix " => ")
      ;; Set character size limit after which the REPL buffer will be trimmed.
      (cider-repl-buffer-size-limit 100000)
      ;; Wrap around REPL input history.
      (cider-repl-wrap-history t)
      ;; Max number of inputs held in history.
      (cider-repl-history-size 1000)
      ;; File for storing CIDER REPL history.
      (cider-repl-history-file
       (file-truename (concat user-emacs-directory "cider-repl-hist")))
      ;; Turn off hover documentation since lsp-mode provides a better alternative.
      (cider-eldoc-display-for-symbol-at-point nil)
      ;; CIDER will try to add expected function arguments based on the current
      ;; context (for example for the datomic.api/q function where it will show the
      ;; expected inputs of the query at point) if this is set to t
      (cider-eldoc-display-context-dependent-info t)
      ;; Whether to prefer local resources as opposed to remote, or TRAMP resouces,
      ;; if local resources are available.
      (cider-prefer-local-resources t)
      ;; Whether to save a file when CIDER loads its buffer.
      ;; 'prompt means to prompt, t means always save, nil means never save.
      (cider-save-file-on-load t)
      ;; Extra paramters to pass to lein, such as dependencies and plugins,
      ;; as well as the final repl command..
      (cider-lein-parameters (my/get-cider-lein-parameters))
      :config
      (my/set-cider-repl-keybindings))
  #+end_src

* clj-refactor
  =clj-refactor= provides refactoring support for Clojure projects. It
  complements the refactoring functionality you'd find in =clojure-mode= and
  CIDER.

  #+begin_src emacs-lisp
    (use-package clj-refactor
      :hook
      (clojure-mode .
                    (lambda ()
                      (clj-refactor-mode 1)
                      ;; This choice of keybinding leaves cider-macroexpand-1
                      ;; unbound
                      (cljr-add-keybindings-with-prefix "C-c C-m")))
      :custom
      ;; disable clj-refactor adding ns to blank files.
      ;; This is for interoperability with lsp-mode.
      ;; lsp-mode takes care of this task.
      (cljr-add-ns-to-blank-clj-files nil)
      ;; Whether to warn the user before parsing the AST.
      (cljr-warn-on-eval nil))
  #+end_src
